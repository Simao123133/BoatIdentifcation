% Generates neural network to imitate MPC from random data
clear
load('mpcdata.mat')
k=1;
for i=1:200
    for j=1:200
        %if k~= 1
        %    if reshape(u(i,j,:),[1 size(u,3)]) ~= mpcoutputs(k-1,:)
        %        ref(k,:) = r(i,:);
        %        mpcoutputs(k,:) = reshape(u(i,j,:),[1 size(u,3)]);
        %        mpcinputs(k,:) = reshape(y(i,j,:),[1 size(y,3)]);
        %        k = k+1;
        %    end
        %else
            ref(k,:) = r(i,:);
            mpcoutputs(k,:) = reshape(u(i,j,:),[1 size(u,3)]);
            mpcinputs(k,:) = reshape(y(i,j,:),[1 size(y,3)]);
            k = k+1;
        %end
    end
end
cont = circshift(mpcoutputs,1,1);
inputs = [ref cont mpcinputs];
outputs = mpcoutputs;

%{
titles = ["uref",'zref','pitchref','rollref','dyawref',"u",'z','pitch','roll','dyaw'];
figure(1)
for i=1:9
subplot(3,3,i)
plot(t,inputs(:,i));
title(titles(i))
end
%}
% Solve an Autoregression Problem with External Input with a NARX Neural Network
% Script generated by Neural Time Series app
% Created 22-Nov-2021 17:46:54
%
% This script assumes these variables are defined:
%
%   inputs - input time series.
%   outputs - feedback time series.

% Choose a Training Function
% For a list of all training functions type: help nntrain
% 'trainlm' is usually fastest.
% 'trainbr' takes longer but may be better for challenging problems.
% 'trainscg' uses less memory. Suitable in low memory situations.
trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.

net = feedforwardnet([10 10],trainFcn);

% Prepare the Data for Training and Simulation
% The function PREPARETS prepares timeseries data for a particular network,
% shifting time by the minimum amount to fill input states and layer
% states. Using PREPARETS allows you to keep your original time series data
% unchanged, while easily customizing it for networks with differing
% numbers of delays, with open loop or closed loop feedback modes.

% Setup Division of Data for Training, Validation, Testing
net.divideParam.trainRatio = 70/100;
net.divideParam.valRatio = 15/100;
net.divideParam.testRatio = 15/100;
net.divideFcn = 'divideblock';
% Train the Network
[net,tr] = train(net,inputs', outputs');

% Test the Network
y = net(inputs');
results = y';
titles = ["LF",'RF','ReF','Rpms','Rudder'];
figure(2)
start =1;
finish = 200;
for i=1:size(u,3)
subplot(2,3,i);
plot(1:length(outputs(tr.testInd(start:finish),1)),outputs(tr.testInd(start:finish),i),1:length(outputs(tr.testInd(start:finish),1)), results(tr.testInd(start:finish),i));
title(titles(i))
legend('MPC','NN') 
end


for i=1:size(u,3)
   MSE(i) =  sum((results(tr.testInd,i) - outputs(tr.testInd,i)).^2)/length(outputs(tr.testInd,1));
end

save('net.mat','net');


